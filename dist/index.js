import{fetchWithTimeout,getAverage,wait}from"@codebundlesbyvik/js-helpers";function convertUnixTimeFormatToMs(time){if("number"!=typeof time||Number.isNaN(time))return console.warn("`time` must be of type `number` and not NaN."),null;const timeString=time.toString().replace(".",""),processedTimeString=timeString.length>16?timeString.slice(0,16):timeString.padEnd(16,"0");return Math.round(Number.parseInt(processedTimeString)/1e3)}function filterOutliers(values){return values.length<5?values:values.sort(((a,b)=>a-b)).slice(1,values.length-2)}const DEFAULT_INSTANCE_OPTIONS={maxSyncAttempts:6,requiredOkSyncAttempts:4};class Ntp{constructor(options){const mergedOptions={...DEFAULT_INSTANCE_OPTIONS,...options};this.t1EndpointUrl=mergedOptions.t1EndpointUrl,this.t1CalcFn=mergedOptions.t1CalcFn,this.t2CalcFn=mergedOptions.t2CalcFn||null,this.maxSyncAttempts=mergedOptions.maxSyncAttempts,this.requiredOkSyncAttempts=mergedOptions.requiredOkSyncAttempts}async generateData(){console.info("generateData: Running...");try{const t0=(new Date).valueOf();console.debug("generateData - t0:",t0);const response=await fetchWithTimeout(this.t1EndpointUrl);if(!response.ok)throw new Error(`t1 data fetch failed with HTTP status code ${response.status}.`);const t1=await this.t1CalcFn(response);if(console.debug("generateData - t1:",t1),null===t1)throw new Error("t1 calculation returned `null`.");let t2=t1;if(this.t2CalcFn){console.debug("generateData: Using provided function for t2 calculation.");const t2CalcFnResult=this.t2CalcFn(response.headers);null!==t2CalcFnResult&&t2CalcFnResult>t1&&(console.debug("generateData: Using t2CalcFnResult."),t2=t2CalcFnResult)}console.debug("generateData - t2:",t2);const t3=(new Date).valueOf();if(console.debug("generateData - t3:",t3),[t0,t1,t2,t3].some((time=>Number.isNaN(time))))throw new Error("Some of the generated time values aren't of type `number`.");const roundTripDelay=t3-t0-(t2-t1),clientOffset=(t1-t0+(t2-t3))/2;return console.debug("generateData: RTD & CO:",[roundTripDelay,clientOffset]),{roundTripDelay,clientOffset}}catch(error){throw error instanceof Error?error:new Error("Unknown error during NTP data generation!")}}async sync(){console.info("sync: Running...");try{const data=[];for(let iteration=0,okIterations=0;iteration<this.maxSyncAttempts;iteration++){console.debug(`sync - fetch loop run: ${iteration}`);try{iteration>this.requiredOkSyncAttempts&&await wait(1e3);const ntpData=await this.generateData();if(data.push(ntpData),okIterations++,okIterations>this.requiredOkSyncAttempts)break}catch(error){console.error(error),iteration<this.maxSyncAttempts-1&&console.debug(`sync: Retrying ${this.maxSyncAttempts-1-iteration} more time(s)!`)}}if(data.length<this.requiredOkSyncAttempts)throw new Error(`Didn't meet the required amount of ${this.requiredOkSyncAttempts} successful sync attempts within the allowed amount of ${this.maxSyncAttempts} total.`);const roundTripDelay=getAverage(filterOutliers(data.map((item=>item.roundTripDelay))),"floor"),clientOffset=getAverage(filterOutliers(data.map((item=>item.clientOffset))),"floor"),values={roundTripDelay,clientOffset,correctedDate:(new Date).valueOf()-clientOffset};return console.debug("sync - values:",values),values}catch(error){throw error instanceof Error?error:new Error("Unknown error during NTP sync!")}}}export{Ntp as default,convertUnixTimeFormatToMs};