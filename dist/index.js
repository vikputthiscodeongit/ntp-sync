import{fetchWithTimeout,getAverage,wait}from"@codebundlesbyvik/js-helpers";function convertUnixTimeFormatToMs(time){if("number"!=typeof time||Number.isNaN(time))return console.warn("`time` must be of type `number` and not NaN."),null;const timeString=time.toString().replace(".",""),processedTimeString=timeString.length>16?timeString.slice(0,16):timeString.padEnd(16,"0");return Math.round(Number.parseInt(processedTimeString)/1e3)}function filterOutliers(values){return values.length<5?values:values.sort(((a,b)=>a-b)).slice(1,values.length-2)}const DEFAULT_INSTANCE_OPTIONS={maxSyncAttempts:6,requiredOkSyncAttempts:4};class Ntp{t1FetchOptions;t1CalcFn;t2CalcFn;maxSyncAttempts;requiredOkSyncAttempts;constructor(options){const mergedOptions={...DEFAULT_INSTANCE_OPTIONS,...options};mergedOptions.t1EndpointUrl&&mergedOptions.t1Endpoint&&console.warn("t1EndpointUrl and t1Endpoint.url are both provided. t1Endpoint.url will take preference.");const t1EndpointUrl=mergedOptions.t1Endpoint?mergedOptions.t1Endpoint.url:mergedOptions.t1EndpointUrl;if(!t1EndpointUrl)throw new Error("t1 endpoint URL must be provided, either as t1EndpointUrl or t1Endpoint.url.");this.t1FetchOptions=[t1EndpointUrl,mergedOptions.t1Endpoint?.fetchOptions,mergedOptions.t1Endpoint?.timeoutDuration],this.t1CalcFn=mergedOptions.t1CalcFn,this.t2CalcFn=mergedOptions.t2CalcFn||null,this.maxSyncAttempts=mergedOptions.maxSyncAttempts,this.requiredOkSyncAttempts=mergedOptions.requiredOkSyncAttempts}async generateData(){try{const t0=(new Date).valueOf(),response=await fetchWithTimeout(...this.t1FetchOptions);if(!response.ok)throw new Error("t1 data fetch failed.");const t1=await this.t1CalcFn(response);if(null===t1)throw new Error("t1 calculation returned `null`.");let t2=t1;if(this.t2CalcFn){const t2CalcFnResult=this.t2CalcFn(response.headers);null!==t2CalcFnResult&&t2CalcFnResult>t1&&(t2=t2CalcFnResult)}const t3=(new Date).valueOf();if([t0,t1,t2,t3].some((time=>Number.isNaN(time))))throw new Error("Some of the time values aren't of type `number`.");return{roundTripDelay:t3-t0-(t2-t1),clientOffset:(t1-t0+(t2-t3))/2}}catch(error){throw error instanceof Error?error:new Error("Unknown error during NTP data generation.")}}async sync(){try{const data=[];for(let iteration=0,okIterations=0;iteration<this.maxSyncAttempts;iteration++)try{iteration>this.requiredOkSyncAttempts&&await wait(1e3);const ntpData=await this.generateData();if(data.push(ntpData),okIterations++,okIterations>this.requiredOkSyncAttempts)break}catch(error){console.error(error),this.maxSyncAttempts}if(data.length<this.requiredOkSyncAttempts)throw new Error(`Didn't meet the required amount of ${this.requiredOkSyncAttempts} successful sync attempts within the allowed amount of ${this.maxSyncAttempts} total.`);const roundTripDelay=getAverage(filterOutliers(data.map((item=>item.roundTripDelay))),"floor"),clientOffset=getAverage(filterOutliers(data.map((item=>item.clientOffset))),"floor");return{roundTripDelay:roundTripDelay,clientOffset:clientOffset,correctedDate:(new Date).valueOf()-clientOffset}}catch(error){throw error instanceof Error?error:new Error("Unknown error during NTP sync.")}}}export{Ntp as default,convertUnixTimeFormatToMs};