import{fetchWithTimeout,getAverage,wait}from"@codebundlesbyvik/js-helpers";function convertUnixTimeFormatToMs(time){if("number"!=typeof time||Number.isNaN(time))return console.warn("`time` must be of type `number` and not NaN."),null;const timeString=time.toString().replace(".",""),processedTimeString=timeString.length>16?timeString.slice(0,16):timeString.padEnd(16,"0");return Math.round(Number.parseInt(processedTimeString)/1e3)}function filterOutliers(values){return values.length<5?values:values.sort((a,b)=>a-b).slice(1,values.length-2)}class Ntp{#t1FetchOptions;t1CalcFn;t2CalcFn;maxSyncAttempts;requiredOkSyncAttempts;constructor(options){this.#t1FetchOptions=(options=>"t1Endpoint"in options)(options)?[options.t1Endpoint.url,options.t1Endpoint.fetchOptions,options.t1Endpoint.timeoutDuration]:[options.t1EndpointUrl],this.t1CalcFn=options.t1CalcFn,this.t2CalcFn=options.t2CalcFn??null,this.maxSyncAttempts=options.maxSyncAttempts??6,this.requiredOkSyncAttempts=options.requiredOkSyncAttempts??4}async generateData(){const t0=(new Date).valueOf(),response=await fetchWithTimeout(...this.#t1FetchOptions);if(!response.ok)throw new Error("t1 data fetch failed.");const t1=await this.t1CalcFn(response);if(null===t1)throw new Error("t1 calculation returned `null`.");let t2=t1;if(this.t2CalcFn){const t2CalcFnResult=this.t2CalcFn(response.headers);null!==t2CalcFnResult&&t2CalcFnResult>=t1?t2=t2CalcFnResult:console.warn("t2 calculation failed. Using t1 as t2.")}const t3=(new Date).valueOf();if([t0,t1,t2,t3].some(time=>Number.isNaN(time)))throw new Error("One or more time values are invalid.");return{roundTripDelay:t3-t0-(t2-t1),clientOffset:(t1-t0+(t2-t3))/2}}async sync(){const data=[];for(let iteration=0,okIterations=0;iteration<this.maxSyncAttempts;iteration++)try{iteration>this.requiredOkSyncAttempts&&await wait(1e3);const ntpData=await this.generateData();if(data.push(ntpData),okIterations++,okIterations>this.requiredOkSyncAttempts)break}catch(error){console.error(error),this.maxSyncAttempts}if(data.length<this.requiredOkSyncAttempts)throw new Error(`Didn't meet the required amount of successful sync attempts (${this.requiredOkSyncAttempts} out of ${this.maxSyncAttempts}).`);const roundTripDelay=getAverage(filterOutliers(data.map(item=>item.roundTripDelay)),"nearest"),clientOffset=getAverage(filterOutliers(data.map(item=>item.clientOffset)),"nearest");return{roundTripDelay:roundTripDelay,clientOffset:clientOffset,correctedDate:Math.round((new Date).valueOf()+clientOffset)}}}export{Ntp as default,convertUnixTimeFormatToMs};